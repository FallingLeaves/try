### Vue 的初始化之开篇

#### 用于初始化的最终选项$options

在 src/core/instance/init.js 中`initMixin`

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
);
```

`mergeOptions`最终将处理合并的选项`return options`返回，作为`vm.$options`的值。vue 提供`Vue.config.optionMergeStrategies`自定义合并选项策略。

#### 渲染函数的作用域代理

在 src/core/instance/init.js 中`initMixin`

```js
/* istanbul ignore else */
if (process.env.NODE_ENV !== "production") {
  initProxy(vm);
} else {
  vm._renderProxy = vm;
}
```

经过`mergeOptions`合并处理选项后，判断当前环境是否为生产环境，为生产环境，执行`initProxy(vm)`，否则为当前 vm 实例添加`_renderProxy`属性，属性值为当前实例。

在 src/core/intance/proxy.js 中

```js
// initProxy定义
let initProxy;

if (process.env.NODE_ENV !== "production") {
  // 其他代码
  ......
  // initProxy初始化
  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      // options对vm.$options 的引用
      const options = vm.$options;
      // handlers可能是getHandler或hasHandler
      const handlers =
        options.render && options.render._withStripped
          ? getHandler
          : hasHandler;
      // 代理vm
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}
//导出initProxy
export { initProxy };
```

在非生产环境，`initProxy`才会被赋值，生产环境下为 undefined。非生产环境下导出`initProxy`函数。

该函数先判断`hasProxy`

```js
const hasProxy = typeof Proxy !== "undefined" && isNative(Proxy);
```

即判断当前环境是否支持原生`Proxy`，支持，对 vm 做一层代理`new Proxy(vm, handlers)`，代理值作为`vm._renderProxy`的属性值，`handlers`取决于`options.render && options.render._withStripped`，`options.render._withStripped`只在测试代码中出现，所以`handlers`为`hasHandler`。

```js
const hasHandler = {
  has(target, key) {
    const has = key in target;
    const isAllowed =
      allowedGlobals(key) || (typeof key === "string" && key.charAt(0) === "_");
    if (!has && !isAllowed) {
      warnNonPresent(target, key);
    }
    return has || !isAllowed;
  }
};
```
