### 以一个例子为线索

html 模板

> `<div id="app">{{test}}</div>`

js

> var vm = new Vue({  
> &emsp;el: "#app",  
> &emsp;data: {  
> &emsp;&emsp;test: "hello"  
> &emsp;}  
> })

最终显示  
`<div id="app">hello</div>`

在 vue 出生文件中  
this.\_init(options)  
options = {  
&emsp;el: "#app",  
&emsp;data: {  
&emsp;&emsp;test: "hello"  
&emsp;}  
}

src/core/instance/init.js 中 initMixin  
\_init 方法  
const vm: Component = this  
定义常量 vm 也就是这个 Vue 实例  
// a uid  
vm.\_uid = uid++  
定义了 vm 的一个唯一标识，每次实例化一个 Vue 就 uid++

let startTag, endTag  
/_ istanbul ignore if _/  
if (process.env.NODE_ENV !== 'production' && config.performance && mark) {  
&emsp;startTag = `vue-perf-start:${vm._uid}`  
&emsp;endTag = `vue-perf-end:${vm._uid}`  
&emsp;mark(startTag)  
}

.....

if (process.env.NODE_ENV !== 'production' && config.performance && mark) {  
&emsp;vm.\_name = formatComponentName(vm, false)  
&emsp;mark(endTag)  
&emsp;measure(`vue ${vm._name} init`, startTag, endTag)  
}

process.env.NODE_ENV !== 'production' && config.performance && mark 当前环境不是生产环境并且 config.performance(全局配置中)并且 mark(浏览器支持 performance.mark 方法)

config.performance 设置 true，可以开启性能追踪，追踪四个场景

- 组件初始化
- 编译，将模板编译成渲染函数
- 渲染，渲染函数的性能，渲染函数执行并且生成虚拟 DOM 的性能
- 打补丁，将虚拟 DOM 转换为真实 DOM

组件初始化性能追踪，就是在 init 函数中执行，在组件开始和结尾通过 mark 函数打上标记，通过 measure 函数对这两个标记进行性能计算

> // a flag to avoid this being observed  
> vm.\_isVue = true  
> // merge options  
> if (options && options.\_isComponent) {  
> &emsp;// optimize internal component instantiation  
> &emsp;// since dynamic options merging is pretty slow, and none of the  
> &emsp;// internal component options needs special treatment.  
> &emsp;initInternalComponent(vm, options)  
> } else {  
> &emsp;vm.$options = mergeOptions(  
> &emsp;&emsp;resolveConstructorOptions(vm.constructor),  
> &emsp;&emsp;options || {},  
> &emsp;&emsp;vm  
> &emsp;)  
> }  
> /_ istanbul ignore else _/  
> if (process.env.NODE_ENV !== 'production') {  
> &emsp;initProxy(vm)  
> } else {  
> &emsp;vm.\_renderProxy = vm  
> }  
> // expose real self  
> vm.\_self = vm  
> initLifecycle(vm)  
> initEvents(vm)  
> initRender(vm)  
> callHook(vm, 'beforeCreate')  
> initInjections(vm) // resolve injections before data/props  
> initState(vm)  
> initProvide(vm) // resolve provide after data/props  
> callHook(vm, 'created')  
> vm.\_isVue = true  
> 在 Vue 实例添加\_isVue 属性，用来标识是否是 Vue 实例  
> // merge options  
> if (options && options.\_isComponent) {  
> &emsp;// optimize internal component instantiation  
> &emsp;// since dynamic options merging is pretty slow, and none of the  
> &emsp;// internal component options needs special treatment.  
> &emsp;initInternalComponent(vm, options)  
> } else {  
> &emsp;vm.$options = mergeOptions(  
> &emsp;&emsp;resolveConstructorOptions(vm.constructor),  
> &emsp;&emsp;options || {},  
> &emsp;&emsp;vm  
> &emsp;)  
> }

options.\_isComponent 是 Vue 创建组件时才会有的内部选项
mergeOptions 创建 Vue 实例的$options 属性，用于 Vue 实例的初始化
