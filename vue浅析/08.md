### 异步更新队列

#### 异步更新的意义

如果是同步更新，每次属性值改变时，就会重新渲染，一次改变多个属性值时，会引发性能问题。异步更新时，每次更新属性后，不会立即重新求值，将需要更新的观察者放入一个异步更新队列。有相同的依赖被收集时，不会重复收集。当所有的属性变化完了，再一次执行队列中的所有观察者的更新方法(`update`方法)。对于渲染函数的观察者，`update`方法最终是执行`queueWatcher`方法。

在src/core/observer/scheduler.js中定义了`queueWatcher`方法，以观察者实例对象为参数。

```js
export function queueWatcher (watcher: Watcher) {
  // 定义id常量，值为观察者实例的唯一id
  const id = watcher.id
  // has是空对象
  // 判断队列中是否有该观察者
  if (has[id] == null) {
    // 将id作为has的属性，值设为true
    has[id] = true
    // flushing表示是否在更新
    // queue是数组，初始值为[]
    // 队列没有更新时，将观察者push到队列
    // 队列更新时，也可能会有观察者添加入队，例如计算属性的观察者
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      // 更新时添加观察者
      // 保证观察者添加的顺序
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    // 无论调用多少次queueWatcher，watch最终都是true，下面的if代码块只会执行一次
    if (!waiting) {
      waiting = true
      // 调用nextTick方法，以flushSchedulerQueue方法为参数
      // flushSchedulerQueue方法作用之一是将队列中的观察者统一更新
      // nextTick可以简单看成setTimeout(fn, 0)
      nextTick(flushSchedulerQueue)
    }
  }
}
```

#### nextTick的实现

在src/core/instance/render.js中的`renderMixin`函数中,`$nextTick`方法就是对`nextTick`的简单封装。  
`$nextTick`只接收一个回调函数(`fn`)作为参数，内部`nextTick`接收这个`fn`，还传入了`this`，当前组件的实例对象。

```js
Vue.prototype.$nextTick = function (fn: Function) {
  return nextTick(fn, this)
}
```

异步任务分为macrotask(宏任务)和microtask(微任务)。  
宏任务：script(全局任务)、setTimeout、setInterval、setImmediate、I/O、UI rendering。  
微任务：process.nextTick、Promise、Object.observer、MutationObserver。    
浏览器中的eventloop遵循HTML5标准，NodeJS遵循libuv。   
浏览器：
1.  取一个宏任务执行，完毕，下一步
2.  取一个微任务执行，完毕，再取微任务。直到微任务队列空，下一步
3.  更新UI渲染

在同一次事件循环内，微任务队列是完全执行完毕的。在微任务队列中，把所有UI渲染需要的数据全部更新完，只需要一次重新渲染就能得到新的DOM。所以优先使用微任务去更新数据，最优使用Promise，浏览器不支持，降级使用setTimeout。

```js
// 判断当前环境是否支持promise
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  // 定义常量p，为立即resolve的promise实例对象
  const p = Promise.resolve()
  // microTimerFunc初始值为undefined
  // 重新赋值，将flushCallbacks函数注册为一个微任务
  microTimerFunc = () => {
    p.then(flushCallbacks)
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    // 在一些UIWebViews中，微任务未触发，注册一个宏任务，间接触发微任务
    if (isIOS) setTimeout(noop)
  }
} else {
  // fallback to macro
  // 不支持promise，降级使用宏任务，将macroTimerFunc赋值给microTimerFunc
  microTimerFunc = macroTimerFunc
}
```

`macroTimerFunc`的赋值，最终作用将`flushCallbacks`注册为宏任务

```js
// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
// 判断宿主环境是否支持setImmediate
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // 使用setImmediate注册宏任务
  // setTimeout在注册宏任务之前，需要不停检测是否超时，setImmediate不需要
  // setImmediate目前只有IE支持
  macroTimerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  // 判断MessageChannel是否可用，MessageChannel不需要任何检测
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () => {
    port.postMessage(1)
  }
} else {
  /* istanbul ignore next */
  // 最终才会使用setTimeout
  macroTimerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```

`nextTick`接收两个参数，第一个是回调函数，第二个是指定作用域。

```js
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve
  // callbacks 初始值为空数组
  // 在callbacks中添加了一个函数，该函数会间接调用cb，并通过call方法修改cb的作用域为ctx
  // 对于$nextTick来讲，ctx为当前组件实例对象
  // 此时cb还未调用，只是用一个新函数包裹，添加到callbacks中
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  // 判断pending，其初始值为false
  // pending代表回调队列是否处于等待刷新状态，false代表回调队列为空，不需要等待刷新
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```