### 数据响应系统

#### 实例对象代理访问数据 data

从`initData`开始探索数据响应系统，在 src/core/instance/state.js 中的`initData`函数。

```js
function initData(vm: Component) {
  // 定义data变量，是vm.$options.data的引用，data选项经过规范化后是一个函数，该函数最终处理后的才是真实数据
  let data = vm.$options.data;
  // 判断data是否是函数(因为beforeCreate钩子在mergeOptions函数之后，initState函数之前调用，在beforeCreate钩子中可能修改vue.$options.data的值，需要对data进行判断)，是函数通过getData拿到数据，并重写了vm的_data属性
  data = vm._data = typeof data === "function" ? getData(data, vm) : data || {};
  // 判断data是不是纯对象，不是就警告data选项应该返回一个对象，并重置data为空对象
  if (!isPlainObject(data)) {
    data = {};
    process.env.NODE_ENV !== "production" &&
      warn(
        "data functions should return an object:\n" +
          "https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function",
        vm
      );
  }
  // proxy data on instance
  // 拿到data所有属性的键，赋值给keys
  const keys = Object.keys(data);
  // props常量是vm.$options.props的引用
  const props = vm.$options.props;
  // methods是vm.$options.methods的引用
  const methods = vm.$options.methods;
  let i = keys.length;
  // 循环keys
  while (i--) {
    // 拿到keys的当前项key
    const key = keys[i];
    // 非生产环境时
    if (process.env.NODE_ENV !== "production") {
      // 如果methods拥有与data相同的属性字段的key，警告methods中定义的函数名已经在data选项中存在
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        );
      }
    }
    // 如果props拥有与data相同的属性字段的key，警告data中定义的字段，在props中已经存在
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== "production" &&
        warn(
          `The data property "${key}" is already declared as a prop. ` +
            `Use prop default value instead.`,
          vm
        );
      // 如果key不是以$或_开头的字段，通过proxy实现实例对象的代理
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key);
    }
  }
  // observe data
  // 调用observe将data转换为响应式的
  observe(data, true /* asRootData */);
}
```

首先定义`data`变量，是`vm.$options.data`的引用，`data`选项经过规范化后是一个函数，该函数最终处理后的才是真实数据  
然后判断`data`是否是函数(因为`beforeCreate`钩子在`mergeOptions`函数之后，`initState`函数之前调用，在`beforeCreate`钩子中可能修改`vue.$options.data`的值，需要对`data`进行判断)，如果是函数通过`getData`拿到数据

```js
export function getData(data: Function, vm: Component): any {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, `data()`);
    return {};
  } finally {
    popTarget();
  }
}
```

`pushTarget`和`popTarget`防止`props`数据初始化`data`数据时的收集冗余依赖

```js
export function proxy(target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}
```

`proxy`通过`Object.defineProperty`在`vm`实例对象上定义与`key`同名的访问器属性，这些属性代理的值是`vm._data`上对应属性值。

`initData`函数中，通过`vm.$options.data`获取数据，判断得到的数据`data`是不是纯对象，检测`methods`选项和`data`选项中是否有同名的键，检测`props`选项和`data`选项是否有同名的键，在 vue 实例对象添加代理访问数据对象的同名属性，最后调用`observe`。

#### 数据响应系统的基本思路

```js
let data = {
  a: 1,
  b: 2,
  c: {
    d: 12
  },
  name: "jack",
  age: 18
};

// 通过walk 遍历data为data创建对应的新属性
function walk(data) {
  for (const key in data) {
    // 依赖收集
    const dep = [];

    let val = data[key];

    const nativeString = Object.prototype.toString.call(val);
    // 如果是对象，递归
    if (nativeString === "[object Object]") {
      walk(val);
    }

    Object.defineProperty(data, key, {
      set(newVal) {
        //console.log(`设置${key}的值`);
        // 没变化直接return
        if (val === newVal) return;
        // 新值替换旧值
        val = newVal;
        // 取值时，执行依赖
        dep.forEach(fn => fn());
      },
      get() {
        //console.log(`获取${key}的值`);
        // 设值时，添加依赖
        Target && dep.push(Target);
        return val;
      }
    });
  }
}

walk(data);

let Target = null;

// $watch最终目的访问到需要的属性，触发get，添加依赖依赖Target
function $watch(exp, fn) {
  Target = fn;

  let pathArr,
    obj = data;
  // 如果检测的是函数，直接执行函数
  if (typeof exp === "function") {
    exp();
    Target = null;
    return;
  }
  // 检测的是c.d进行转换，拿到最后的d
  if (/\./.test(exp)) {
    pathArr = exp.split(".");
    pathArr.forEach(p => {
      obj = obj[p];
    });
    Target = null;
    return;
  }

  data[exp];
  Target = null;
}

function render() {
  document.write(`姓名:${data.name},年龄:${data.age}`);
}

$watch("a", () => {
  console.log("第一个依赖");
});

$watch("b", () => {
  console.log("第二个依赖");
});

$watch("c.d", () => {
  console.log("第三个依赖");
});

$watch(render, render);
```

这个简单的案例中，第一个参数 render 会触发 get，第二个参数 render 又会触发 get，依赖收集了两次，需要避免重复的依赖。

#### observe 工厂函数

在 src/core/observer/index.js 中定义了`observe`函数

```js
export function observe(value: any, asRootData: ?boolean): Observer | void {
  // 如果value不是对象 或 是 VNode实例，直接return
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  // 定义ob变量
  let ob: Observer | void;
  // 检测数据对象value是否拥有__ob__属性，并且value.__ob__是Observer的实例，数据被观测后，会在该数据上添加__ob__属性
  if (hasOwn(value, "__ob__") && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    // 对数据进行观测
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}
```

`observe`接收两个参数，第一个参数为需要观测的数据，第二个数据为 Boolean 值，代表观测的数据是否是根级数据。

数据对象`value`没有`__ob__`属性并且满足其他条件`shouldObserve &&!isServerRendering() &&(Array.isArray(value) || isPlainObject(value)) &&Object.isExtensible(value) &&!value._isVue`，才会`ob = new Observer(value)`对数据进行观测。

- 第一个条件`shouldObserve`必须为 true

  ```js
  export let shouldObserve: boolean = true;

  export function toggleObserving(value: boolean) {
    shouldObserve = value;
  }
  ```

  `shouldObserve`初始为 true，`toggleObserving`函数改变`shouldObserve`的值。

- 第二个条件`!isServerRendering()`必须为 true
  `isServerRendering`函数用来判断是否是服务端渲染，返回一个 Boolean 值。不是服务端渲染才会观测数据。

- 第三个条件`(Array.isArray(value) || isPlainObject(value))`
  `value`是数组或纯对象才会观测。

- 第四个条件`Object.isExtensible(value)`
  `value`必须是可扩展的。一个默认的对象是可扩展的，`Object.preventExtensions()`、`Object.freeze()` 以及 `Object.seal()`可以使对象变得不可扩展。

- 第五个条件`!value._isVue`
  `value`不是 vue 实例对象，避免观测 vue 实例对象。

满足上述五个条件，才会创建`Observer`实例。

#### Observer 构造函数

在 src/core/observer/index.js 中

```js
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that has this object as root $data

  constructor(value: any) {
    // 省略......
  }

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk(obj: Object) {
    // 省略.....
  }

  /**
   * Observe a list of Array items.
   */
  observeArray(items: Array<any>) {
    // 省略.....
  }
}
```

`Observer`类的实例对象将会拥有`value`、`dep`和`vmCount`三个属性，以及`walk`、`observeArray`两个方法。`Observer`构造函数接收一个参数`value`即观测数据。

#### 观测数据的__ob__属性

```js
constructor (value: any) {
  // 实例对象的value属性引用了观测数据value
  this.value = value
  // 实例对象的dep属性是一个Dep的实例对象
  this.dep = new Dep()
  // 实例对象的vmCount属性初始为0
  this.vmCount = 0
  // def是Object.defineProperty的简单封装，可以定义不可枚举的属性
  // 在观测数据上定义__ob__属性
  def(value, '__ob__', this)
  // 如果value是数组
  if (Array.isArray(value)) {
    const augment = hasProto
      ? protoAugment
      : copyAugment
    augment(value, arrayMethods, arrayKeys)
    this.observeArray(value)
  } else {
    this.walk(value)
  }
}
```
